<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>DeepAR Forecasting Algorithm</title>
  <style>
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<p>
Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.<br>SPDX-License-Identifier: CC-BY-SA-4.0
</p>
<header id="title-block-header">
<h1 class="title">DeepAR Forecasting Algorithm<a name="deepar"></a></h1>
</header>
<p>The Amazon SageMaker DeepAR forecasting algorithm is a supervised learning algorithm for forecasting scalar (one-dimensional) time series using recurrent neural networks (RNN). Classical forecasting methods, such as autoregressive integrated moving average (ARIMA) or exponential smoothing (ETS), fit a single model to each individual time series. They then use that model to extrapolate the time series into the future.</p>
<p>In many applications, however, you have many similar time series across a set of cross-sectional units. For example, you might have time series groupings for demand for different products, server loads, and requests for webpages. For this type of application, you can benefit from training a single model jointly over all of the time series. DeepAR takes this approach. When your dataset contains hundreds of related time series, DeepAR outperforms the standard ARIMA and ETS methods. You can also use the trained model to generate forecasts for new time series that are similar to the ones it has been trained on.</p>
<p>The training input for the DeepAR algorithm is one or, preferably, more <code>target</code> time series that have been generated by the same process or similar processes. Based on this input dataset, the algorithm trains a model that learns an approximation of this process/processes and uses it to predict how the target time series evolves. Each target time series can be optionally associated with a vector of static (time-independent) categorical features provided by the <code>cat</code> field and a vector of dynamic (time-dependent) time series provided by the <code>dynamic_feat</code> field. Amazon SageMaker trains the DeepAR model by randomly sampling training examples from each target time series in the training dataset. Each training example consists of a pair of adjacent context and prediction windows with fixed predefined lengths. To control how far in the past the network can see, use the <code>context_length</code> hyperparameter. To control how far in the future predictions can be made, use the <code>prediction_length</code> hyperparameter. For more information, see <a href="deepar_how-it-works.md">How the DeepAR Algorithm Works</a>.</p>
<p><strong>Topics</strong> + <a href="#deepar-inputoutput">Input/Output Interface for the DeepAR Algorithm</a> + <a href="#deepar_best_practices">Best Practices for Using the DeepAR Algorithm</a> + <a href="#deepar-instances">EC2 Instance Recommendations for the DeepAR Algorithm</a> + <a href="#deepar-sample-notebooks">DeepAR Sample Notebooks</a> + <a href="deepar_how-it-works.md">How the DeepAR Algorithm Works</a> + <a href="deepar_hyperparameters.md">DeepAR Hyperparameters</a> + <a href="deepar-tuning.md">Tune a DeepAR Model</a> + <a href="deepar-in-formats.md">DeepAR Inference Formats</a></p>
<p>DeepAR supports two data channels. The required <code>train</code> channel describes the training dataset. The optional <code>test</code> channel describes a dataset that the algorithm uses to evaluate model accuracy after training. You can provide training and test datasets in <a href="http://jsonlines.org/">JSON Lines</a> format. Files can be in gzip or <a href="https://parquet.apache.org/">Parquet</a> file format.</p>
<p>When specifying the paths for the training and test data, you can specify a single file or a directory that contains multiple files, which can be stored in subdirectories. If you specify a directory, DeepAR uses all files in the directory as inputs for the corresponding channel, except those that start with a period (.) and those named <em>_SUCCESS</em>. This ensures that you can directly use output folders produced by Spark jobs as input channels for your DeepAR training jobs.</p>
<p>By default, the DeepAR model determines the input format from the file extension (<code>.json</code>, <code>.json.gz</code>, or <code>.parquet</code>) in the specified input path. If the path does not end in one of these extensions, you must explicitly specify the format in the SDK for Python. Use the <code>content_type</code> parameter of the <a href="https://sagemaker.readthedocs.io/en/stable/session.html#sagemaker.session.s3_input">s3_input</a> class.</p>
<p>The records in your input files should contain the following fields: + <code>start</code>—A string with the format <code>YYYY-MM-DD HH:MM:SS</code>. The start timestamp can’t contain time zone information. + <code>target</code>—An array of floating-point values or integers that represent the time series. You can encode missing values as <code>null</code> literals, or as <code>"NaN"</code> strings in JSON, or as <code>nan</code> floating-point values in Parquet. + <code>dynamic_feat</code> (optional)—An array of arrays of floating-point values or integers that represents the vector of custom feature time series (dynamic features). If you set this field, all records must have the same number of inner arrays (the same number of feature time series). In addition, each inner array must have the same length as the associated <code>target</code> value. Missing values are not supported in the features. For example, if target time series represents the demand of different products, an associated <code>dynamic_feat</code> might be a boolean time-series which indicates whether a promotion was applied (1) to the particular product or not (0):</p>
<pre><code>{&quot;start&quot;: ..., &quot;target&quot;: [1, 5, 10, 2], &quot;dynamic_feat&quot;: [[0, 1, 1, 0]]}</code></pre>
<ul>
<li><code>cat</code> (optional)—An array of categorical features that can be used to encode the groups that the record belongs to. Categorical features must be encoded as a 0-based sequence of positive integers. For example, the categorical domain {R, G, B} can be encoded as {0, 1, 2}. All values from each categorical domain must be represented in the training dataset. That’s because the DeepAR algorithm can forecast only for categories that have been observed during training. And, each categorical feature is embedded in a low-dimensional space whose dimensionality is controlled by the <code>embedding_dimension</code> hyperparameter. For more information, see <a href="deepar_hyperparameters.md">DeepAR Hyperparameters</a>.</li>
</ul>
<p>If you use a JSON file, it must be in <a href="http://jsonlines.org/">JSON Lines</a> format. For example:</p>
<pre><code>{&quot;start&quot;: &quot;2009-11-01 00:00:00&quot;, &quot;target&quot;: [4.3, &quot;NaN&quot;, 5.1, ...], &quot;cat&quot;: [0, 1], &quot;dynamic_feat&quot;: [[1.1, 1.2, 0.5, ...]]}
{&quot;start&quot;: &quot;2012-01-30 00:00:00&quot;, &quot;target&quot;: [1.0, -5.0, ...], &quot;cat&quot;: [2, 3], &quot;dynamic_feat&quot;: [[1.1, 2.05, ...]]}
{&quot;start&quot;: &quot;1999-01-30 00:00:00&quot;, &quot;target&quot;: [2.0, 1.0], &quot;cat&quot;: [1, 4], &quot;dynamic_feat&quot;: [[1.3, 0.4]]}</code></pre>
<p>In this example, each time series has two associated categorical features and one time series features.</p>
<p>For Parquet, you use the same three fields as columns. In addition, <code>"start"</code> can be the <code>datetime</code> type. You can compress Parquet files using gzip (<code>gzip</code>) or the Snappy compression library (<code>snappy</code>).</p>
<p>If the algorithm is trained without <code>cat</code> and <code>dynamic_feat</code> fields, it learns a “global” model, that is a model that is agnostic to the specific identity of the target time series at inference time and is conditioned only on its shape.</p>
<p>If the model is conditioned on the <code>cat</code> and <code>dynamic_feat</code> feature data provided for each time series, the prediction will probably be influenced by the character of time series with the corresponding <code>cat</code> features. For example, if the <code>target</code> time series represents the demand of clothing items, you can associate a two-dimensional <code>cat</code> vector that encodes the type of item (e.g. 0 = shoes, 1 = dress) in the first component and the color of an item (e.g. 0 = red, 1 = blue) in the second component. A sample input would look as follows:</p>
<pre><code>{ &quot;start&quot;: ..., &quot;target&quot;: ..., &quot;cat&quot;: [0, 0], ... } # red shoes
{ &quot;start&quot;: ..., &quot;target&quot;: ..., &quot;cat&quot;: [1, 1], ... } # blue dress</code></pre>
<p>At inference time, you can request predictions for targets with <code>cat</code> values that are combinations of the <code>cat</code> values observed in the training data, for example:</p>
<pre><code>{ &quot;start&quot;: ..., &quot;target&quot;: ..., &quot;cat&quot;: [0, 1], ... } # red dress
{ &quot;start&quot;: ..., &quot;target&quot;: ..., &quot;cat&quot;: [1, 1], ... } # blue dress</code></pre>
<p>The following guidelines apply to training data: + The start time and length of the time series can differ. For example, in marketing, products often enter a retail catalog at different dates, so their start dates naturally differ. But all series must have the same frequency, number of categorical features, and number of dynamic features. + Shuffle the training file with respect to the position of the time series in the file. In other words, the time series should occur in random order in the file. + Make sure to set the <code>start</code> field correctly. The algorithm uses the <code>start</code> timestamp to derive the internal features. + If you use categorical features (<code>cat</code>), all time series must have the same number of categorical features. If the dataset contains the <code>cat</code> field, the algorithm uses it and extracts the cardinality of the groups from the dataset. By default, <code>cardinality</code> is <code>"auto"</code>. If the dataset contains the <code>cat</code> field, but you don’t want to use it, you can disable it by setting <code>cardinality</code> to <code>""</code>. If a model was trained using a <code>cat</code> feature, you must include it for inference. + If your dataset contains the <code>dynamic_feat</code> field, the algorithm uses it automatically. All time series have to have the same number of feature time series. The time points in each of the feature time series correspond one-to-one to the time points in the target. In addition, the entry in the <code>dynamic_feat</code> field should have the same length as the <code>target</code>. If the dataset contains the <code>dynamic_feat</code> field, but you don’t want to use it, disable it by setting(<code>num_dynamic_feat</code> to <code>""</code>). If the model was trained with the <code>dynamic_feat</code> field, you must provide this field for inference. In addition, each of the features has to have the length of the provided target plus the <code>prediction_length</code>. In other words, you must provide the feature value in the future.</p>
<p>If you specify optional test channel data, the DeepAR algorithm evaluates the trained model with different accuracy metrics. The algorithm calculates the root mean square error (RMSE) over the test data as follows:</p>
<figure>
<img src="http://docs.aws.amazon.com/sagemaker/latest/dg/images/deepar-1.png" alt="" /><figcaption>[RMSE Formula: Sqrt(1/nT(Sum<a href="y-hat(i,t)-y(i,t)">i,t</a>^2))]</figcaption>
</figure>
<p>*y**i<em>,</em>t* is the true value of time series <em>i</em> at the time <em>t</em>. *ŷ**i<em>,</em>t* is the mean prediction. The sum is over all <em>n</em> time series in the test set and over the last Τ time points for each time series, where Τ corresponds to the forecast horizon. You specify the length of the forecast horizon by setting the <code>prediction_length</code> hyperparameter. For more information, see <a href="deepar_hyperparameters.md">DeepAR Hyperparameters</a>.</p>
<p>In addition, the algorithm evaluates the accuracy of the forecast distribution using weighted quantile loss. For a quantile in the range [0, 1], the weighted quantile loss is defined as follows:</p>
<figure>
<img src="http://docs.aws.amazon.com/sagemaker/latest/dg/images/deepar-2.png" alt="" /><figcaption>[Quantile loss]</figcaption>
</figure>
<p>*q**i<em>,</em>t*(τ) is the τ-quantile of the distribution that the model predicts. To specify which quantiles to calculate loss for, set the <code>test_quantiles</code> hyperparameter. In addition to these, the average of the prescribed quantile losses is reported as part of the training logs. For information, see <a href="deepar_hyperparameters.md">DeepAR Hyperparameters</a>.</p>
<p>For inference, DeepAR accepts JSON format and the following fields: + <code>"instances"</code>, which includes one or more time series in JSON Lines format + A name of <code>"configuration"</code>, which includes parameters for generating the forecast</p>
<p>For more information, see <a href="deepar-in-formats.md">DeepAR Inference Formats</a>.</p>
<p>When preparing your time series data, follow these best practices to achieve the best results: + Except for when splitting your dataset for training and testing, always provide the entire time series for training, testing, and when calling the model for inference. Regardless of how you set <code>context_length</code>, don’t break up the time series or provide only a part of it. The model uses data points further back than the value set in <code>context_length</code> for the lagged values feature. + When tuning a DeepAR model, you can split the dataset to create a training dataset and a test dataset. In a typical evaluation, you would test the model on the same time series used for training, but on the future <code>prediction_length</code> time points that follow immediately after the last time point visible during training. You can create training and test datasets that satisfy this criteria by using the entire dataset (the full length of all time series that are available) as a test set and removing the last <code>prediction_length</code> points from each time series for training. During training, the model doesn’t see the target values for time points on which it is evaluated during testing. During testing, the algorithm withholds the last <code>prediction_length</code> points of each time series in the test set and generates a prediction. Then it compares the forecast with the withheld values. You can create more complex evaluations by repeating time series multiple times in the test set, but cutting them at different endpoints. With this approach, accuracy metrics are averaged over multiple forecasts from different time points. For more information, see <a href="deepar-tuning.md">Tune a DeepAR Model</a>. + Avoid using very large values (&gt;400) for the <code>prediction_length</code> because it makes the model slow and less accurate. If you want to forecast further into the future, consider aggregating your data at a higher frequency. For example, use <code>5min</code> instead of <code>1min</code>. + Because lags are used, a model can look further back in the time series than the value specified for <code>context_length</code>. Therefore, you don’t need to set this parameter to a large value. We recommend starting with the value that you used for <code>prediction_length</code>. + We recommend training a DeepAR model on as many time series as are available. Although a DeepAR model trained on a single time series might work well, standard forecasting algorithms, such as ARIMA or ETS, might provide more accurate results. The DeepAR algorithm starts to outperform the standard methods when your dataset contains hundreds of related time series. Currently, DeepAR requires that the total number of observations available across all training time series is at least 300.</p>
<p>You can train DeepAR on both GPU and CPU instances and in both single and multi-machine settings. We recommend starting with a single CPU instance (for example, ml.c4.2xlarge or ml.c4.4xlarge), and switching to GPU instances and multiple machines only when necessary. Using GPUs and multiple machines improves throughput only for larger models (with many cells per layer and many layers) and for large mini-batch sizes (for example, greater than 512).</p>
<p>For inference, DeepAR supports only CPU instances.</p>
<p>Specifying large values for <code>context_length</code>, <code>prediction_length</code>, <code>num_cells</code>, <code>num_layers</code>, or <code>mini_batch_size</code> can create models that are too large for small instances. In this case, use a larger instance type or reduce the values for these parameters. This problem also frequently occurs when running hyperparameter tuning jobs. In that case, use an instance type large enough for the model tuning job and consider limiting the upper values of the critical parameters to avoid job failures.</p>
<p>For a sample notebook that shows how to prepare a time series dataset for training the Amazon SageMaker DeepAR algorithm and how to deploy the trained model for performing inferences, see <a href="https://github.com/awslabs/amazon-sagemaker-examples/blob/master/introduction_to_amazon_algorithms/deepar_synthetic/deepar_synthetic.ipynb">Time series forecasting with DeepAR - Synthetic data</a> as well as <a href="https://github.com/awslabs/amazon-sagemaker-examples/blob/master/introduction_to_amazon_algorithms/deepar_electricity/DeepAR-Electricity.ipynb">DeepAR demo on electricity dataset</a>, which illustrates the advanced features of DeepAR on a real world dataset. For instructions on creating and accessing Jupyter notebook instances that you can use to run the example in Amazon SageMaker, see <a href="nbi.md">Use Notebook Instances</a>. After creating and opening a notebook instance, choose the <strong>SageMaker Examples</strong> tab to see a list of all of the Amazon SageMaker examples. To open a notebook, choose its <strong>Use</strong> tab, and choose <strong>Create copy</strong>.</p>
</body>
</html>
